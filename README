.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.32
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Config::Validate 3"
.TH Config::Validate 3 "2008-02-07" "perl v5.8.8" "User Contributed Perl Documentation"
.SH "NAME"
Config::Validate \- Validate data structures generated from
configuration files. (Or anywhere else)
.SH "VERSION"
.IX Header "VERSION"
Version 0.2.0
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module is for validating configuration data that has been read in
already and is in a Perl data structure.  It does not handle reading
or parsing configuration files since there are a plethora of available
modules on \s-1CPAN\s0 to do that task.  Instead it concentrates on verifying
that the data read is correct, and providing defaults where
appropriate.  It also allows you to specify that a given configuration
key may be available under several aliases, and have those renamed to
the canonical name automatically.
.PP
The basic model used is that the caller provides a schema as a perl
data structure that describes the constraints to verify against.  The
caller can then use the \f(CW\*(C`Config::Validate\*(C'\fR object to validate any
number of data structures against the configured schema.  If the data
structure conforms to the schema given, then a new data structure will
be returned, otherwise an exception is thrown.
.PP
Probably the easiest way to explain the intent is that
\&\f(CW\*(C`Config::Validate\*(C'\fR is trying to be like \f(CW\*(C`Params::Validate\*(C'\fR for
configuration files and other data structures.
.PP
This module has the following features:
.IP "* Data structure depth is only limited by stack depth" 4
.IX Item "Data structure depth is only limited by stack depth"
.PD 0
.IP "* Can provide defaults for missing items at any level of the data structure." 4
.IX Item "Can provide defaults for missing items at any level of the data structure."
.IP "* Can require that items exist, or items can be optional." 4
.IX Item "Can require that items exist, or items can be optional."
.IP "* Can validate items in the data structure against a number of built in data types, and users can easily add more data types." 4
.IX Item "Can validate items in the data structure against a number of built in data types, and users can easily add more data types."
.IP "* Configuration keys can be known by several names, and will be normalized to the canonical name in the data structure returned by the validation." 4
.IX Item "Configuration keys can be known by several names, and will be normalized to the canonical name in the data structure returned by the validation."
.PD
.SH "SCHEMA DEFINITION"
.IX Header "SCHEMA DEFINITION"
The most complex part of using \f(CW\*(C`Config::Validate\*(C'\fR is defining the
schema to validate against.  The schema takes the form of set of
nested hashes.
.PP
Here is an example schema you might use if you were writing something
that needs to validate a database connection configuration file.
.PP
.Vb 44
\&  my $schema = { db => { 
\&                    type => 'nested',
\&                    alias => 'dbinfo',
\&                    child => { 
\&                       hostname => { 
\&                          type => 'hostname'
\&                          alias => [ qw(host server) ],
\&                          default => 'localhost,
\&                       },
\&                       port => { 
\&                          type => 'integer',
\&                          max => 64*1024 - 1,
\&                          min => 1,
\&                          default => '3306',
\&                       },
\&                       username => { 
\&                          type => 'string'
\&                          optional => 1,
\&                          alias => 'user',
\&                       },
\&                       password => { 
\&                          type => 'string',
\&                          optional => 1,
\&                          alias => [ qw(pass passwd) ],
\&                       },
\&                       database => {
\&                          type => 'string',
\&                          alias => 'dbname',
\&                       },
\&                       column_types => {
\&                          type => 'hash',
\&                          keytype => 'string',
\&                          child => {
\&                            id => { 
\&                               type => 'string',
\&                               default => 'INT',
\&                          },
\&                       },
\&                    },
\&                 allowed_users => {
\&                    type => 'array',
\&                    subtype => 'string',
\&                 },
\&              };
.Ve
.PP
This is a somewhat long example of what a schema can look like.  This
uses most of the features available.  The basic format is that a
schema consists of a hash of hashes.  Each of it's children describe a
single field in the data structure to be validated.  The only required
key in the field definition is \f(CW\*(C`type\*(C'\fR, which defines how that element
in the data/config hash should be validated.
.Sh "\s-1VALIDATION\s0 \s-1TYPES\s0"
.IX Subsection "VALIDATION TYPES"
Below is a list of the built in validation types, and the options they
take.  There are several global options that any of these can take
that are documented below.
.PP
\fInested\fR
.IX Subsection "nested"
.PP
The \f(CW\*(C`nested\*(C'\fR type provides a way to validate nested hash references.
Valid options are:
.IP "* child" 8
.IX Item "child"
Hash reference that defines all the valid keys and values in the
nested section.  Required.
.PP
\fIinteger\fR
.IX Subsection "integer"
.PP
The \f(CW\*(C`integer\*(C'\fR type expects a whole number that can be positive or
negative.  Valid options are:
.IP "* min" 8
.IX Item "min"
Smallest valid value
.IP "* max" 8
.IX Item "max"
Largest valid value
.PP
\fIfloat\fR
.IX Subsection "float"
.PP
The \f(CW\*(C`float\*(C'\fR type verifies that the value meets the
\&\f(CW\*(C`looks_like_number\*(C'\fR test from Scalar::Util.  Valid options are:
.IP "* min" 8
.IX Item "min"
Smallest valid value
.IP "* max" 8
.IX Item "max"
Largest valid value
.PP
\fIstring\fR
.IX Subsection "string"
.PP
The \f(CW\*(C`string\*(C'\fR type does no validation if no addition restrictions are
specified.  Valid options are:
.IP "* min" 8
.IX Item "min"
Minimum length
.IP "* max" 8
.IX Item "max"
Maximum length
.IP "* regex" 8
.IX Item "regex"
String must match the regex provided.
.PP
\fIboolean\fR
.IX Subsection "boolean"
.PP
The \f(CW\*(C`boolean\*(C'\fR type looks for a number of specific values, and converts
them to \f(CW0\fR or \f(CW1\fR.  The values considered to be true are: \f(CW1\fR,
\&\f(CW\*(C`y\*(C'\fR, \f(CW\*(C`yes\*(C'\fR, \f(CW\*(C`t\*(C'\fR, \f(CW\*(C`true\*(C'\fR and \f(CW\*(C`on\*(C'\fR.  The values considered to be
false are \f(CW0\fR, \f(CW\*(C`n\*(C'\fR, \f(CW\*(C`no\*(C'\fR, \f(CW\*(C`f\*(C'\fR, \f(CW\*(C`false\*(C'\fR, \f(CW\*(C`off\*(C'\fR.  These values are
not case sensitive.  The \f(CW\*(C`boolean\*(C'\fR type takes no options.
.PP
\fIdirectory\fR
.IX Subsection "directory"
.PP
The \f(CW\*(C`directory\*(C'\fR type verifies that the value is a directory that
exists.  The \f(CW\*(C`directory\*(C'\fR type takes no options.
.PP
\fIfile\fR
.IX Subsection "file"
.PP
The \f(CW\*(C`file\*(C'\fR type verifies that the value is a file, or a symlink that
points at a file that exists.  The \f(CW\*(C`file\*(C'\fR type takes no options.
.PP
\fIdomain\fR
.IX Subsection "domain"
.PP
The \f(CW\*(C`domain\*(C'\fR type uses the Data::Validate::Domain \f(CW\*(C`is_domain\*(C'\fR
function to verify that the value is a validate domain name.  This
does not look the value up in \s-1DNS\s0 and verify that it exists.  The
\&\f(CW\*(C`domain\*(C'\fR type takes no options.
.PP
\fIhostname\fR
.IX Subsection "hostname"
.PP
The \f(CW\*(C`hostname\*(C'\fR type uses the Data::Validate::Domain \f(CW\*(C`is_hostname\*(C'\fR
function to verify that the value is a validate hostname name.  This
does not look the value up in \s-1DNS\s0 and verify that it exists.  The
\&\f(CW\*(C`hostname\*(C'\fR type takes no options.
.PP
\fIarray\fR
.IX Subsection "array"
.PP
The \f(CW\*(C`array\*(C'\fR type verifies that the value is an array reference.  If
the \f(CW\*(C`array_allows_scalar\*(C'\fR option is turned on (it is by default),
then if a scalar value is found, then it will automatically be
converted to an array reference with a single element.
.IP "* subkey" 8
.IX Item "subkey"
Required option that specifies the type of the elements of the array.
.PP
\fIhash\fR
.IX Subsection "hash"
.PP
The \f(CW\*(C`hash\*(C'\fR type validates a hash reference of key/value pairs.  
.IP "* keytype" 8
.IX Item "keytype"
Required option that specifies the type of validation to do on hash
keys 
.IP "* child" 8
.IX Item "child"
If the \f(CW\*(C`hash\*(C'\fR type finds a \f(CW\*(C`child\*(C'\fR option, then it will validate any
keys in the hash against the fields in the \f(CW\*(C`child\*(C'\fR definition.  Note
that it is \fB\s-1NOT\s0\fR an error if elements are found in the hash that are not
in child.  If you want that behavior, you should use the \f(CW\*(C`nested\*(C'\fR
type instead.
.Sh "\s-1COMMON\s0 \s-1OPTIONS\s0"
.IX Subsection "COMMON OPTIONS"
There are a set of options that can be added to any field definition,
that provide a common set of functionality to all.
.IP "* alias" 8
.IX Item "alias"
The \f(CW\*(C`alias\*(C'\fR option allows you to specify other names that a
particular field might be known by.  For example, you may have a field
named \f(CW\*(C`password\*(C'\fR, but also want to accept \f(CW\*(C`pass\*(C'\fR, \f(CW\*(C`passwd\*(C'\fR and
\&\f(CW\*(C`pw\*(C'\fR.  If any of the aliases are found, then they will be renamed in
the data structure that is returned by \f(CW\*(C`validate\*(C'\fR.  This option can
point to a scalar, or an array reference.
.IP "* callback" 8
.IX Item "callback"
The \f(CW\*(C`callback\*(C'\fR option allows you to specify a callback that will be
called after any other validation has been done for a specific field
in the data structure.  The callback sub is called with a reference to
the \f(CW\*(C`Config::Validate\*(C'\fR object (one is created automatically if you're
using the functional interface), the value to be verified, the
definition of the field, and an array reference containing the path
into the data structure.  You can use the \f(CW\*(C`mkpath\*(C'\fR method to convert
the path to a more readable form for error messages and such.
.IP "* default" 8
.IX Item "default"
The \f(CW\*(C`default\*(C'\fR option allows you to specify a default for the field.
This implicitly means the field is not required to exist in the data
structure being validated.  As many levels as necessary will be
created in the resulting data structure to insure the default is created.
.IP "* optional" 8
.IX Item "optional"
If the \f(CW\*(C`optional\*(C'\fR option is true, then the field is not required.  If
\&\f(CW\*(C`optional\*(C'\fR is false, or not defined, then the field is required.
.SH "SUBROUTINES/METHODS"
.IX Header "SUBROUTINES/METHODS"
.Sh "new"
.IX Subsection "new"
The new method constructs a \f(CW\*(C`Config::Validate\*(C'\fR object, and returns
it.  It accepts the following arguments:
.IP "* schema" 8
.IX Item "schema"
A validation schema as described in the \*(L"\s-1SCHEMA\s0 \s-1DEFINITION\s0\*(R" section
above. 
.IP "* data_path" 8
.IX Item "data_path"
If this is set to true, and the \f(CW\*(C`Data::Path\*(C'\fR module is available,
then the \f(CW\*(C`validate\*(C'\fR method/function will encapsulate the results
returned in a \f(CW\*(C`Data::Path\*(C'\fR instance.  Defaults to false;
.IP "* data_path_options" 8
.IX Item "data_path_options"
If the \f(CW\*(C`data_path\*(C'\fR option is true, then this should be a hash
reference to be passed in as the second argument to the \f(CW\*(C`Data:Path\*(C'\fR
constructor.
.IP "* array_allows_scalar" 8
.IX Item "array_allows_scalar"
If this is true, then scalars will be autopromoted to a single element
array reference when validating \f(CW\*(C`array\*(C'\fR types.
.IP "* debug" 8
.IX Item "debug"
Enables debugging output.
.IP "* on_debug" 8
.IX Item "on_debug"
Allows you to define a callback for debugging output.  A default
callback will be provided if this isn't set.  The default callback
simply prints the debug output to \s-1STDOUT\s0.  If you set the callback,
then will be called with the object as the first parameter, and the
additional parameters should be joined to form the entire message.
.PP
In addition, any of these can read or changed after the object is
created, via an accessor with the same name as the parameter.
.Sh "validate"
.IX Subsection "validate"
The validate sub can be called as either a function, or as a instance
method.  
.PP
If it is called as an instance method, then it expects a single
\&\f(CW\*(C`config\*(C'\fR parameter which should be the data structure/config to be
validated.
.PP
.Vb 1
\&  my $result = $obj->validate(config => $config)
.Ve
.PP
If it is called as a function, then it accepts two parameters.  The
\&\f(CW\*(C`config\*(C'\fR parameter should be the data structure/config to be validated,
and the \f(CW\*(C`schema\*(C'\fR parameter should be the schema.
.PP
.Vb 1
\&  my $result = validate(config => $config, schema => $schema)
.Ve
.PP
The \f(CW\*(C`config\*(C'\fR parameter above can be a hash reference, or it can be a
\&\f(CW\*(C`Config::General\*(C'\fR object.  If it is a \f(CW\*(C`Config::General\*(C'\fR object, then
the validate sub will automatically call the \f(CW\*(C`getall\*(C'\fR method on the
object.
.PP
If any errors are encountered, then the validate sub will call die to
throw an exception.  In that case the value of \f(CW$@\fR contain an error
message describing the problem.
.PP
There was formerly a one and two argument variant of this sub.  It is
still supported, but deprecated.
.Sh "add_type"
.IX Subsection "add_type"
The \f(CW\*(C`add_type\*(C'\fR method allows you to register a validation type on
just a single instance of \f(CW\*(C`Config::Validate\*(C'\fR.  The parameters are as
follows: 
.IP "* name" 8
.IX Item "name"
This is the name to be specified in the schema to use this validation
type.  This is a mandatory parameter.
.IP "* validate" 8
.IX Item "validate"
The value of \f(CW\*(C`validate\*(C'\fR should be a callback that will be run when it
is necessary to validate a field of this type.  The callback will be
passed the \f(CW\*(C`Config::Validate\*(C'\fR object, the name of the field being
validated, the schema definition of that field, and an array reference
containing the path into the data structure.  You can use the
\&\f(CW\*(C`mkpath\*(C'\fR method to convert the path to a more readable form for error
messages and such.
.IP "* init" 8
.IX Item "init"
The value of \f(CW\*(C`init\*(C'\fR should be a callback that will be run before any
validation is done.  The callback will be passed the
\&\f(CW\*(C`Config::Validate\*(C'\fR object, the schema, and the configuration being
validated.
.IP "* finish" 8
.IX Item "finish"
The value of \f(CW\*(C`finish\*(C'\fR should be a callback that will be run after any
validation is done.  The callback will be passed the
\&\f(CW\*(C`Config::Validate\*(C'\fR object, the schema, and the configuration being
validated.
.Sh "add_default_type"
.IX Subsection "add_default_type"
The \f(CW\*(C`add_default_type\*(C'\fR method allows you to register a validation
type for all new \f(CW\*(C`Config::Validate\*(C'\fR instances.  It can be called as a
function, class method, or instance method.  If it is called as an
instance method, then the new type will also be added to that
instance.  The parameters are the same as \f(CW\*(C`add_type\*(C'\fR.
.Sh "reset_default_types"
.IX Subsection "reset_default_types"
The \f(CW\*(C`reset_default_types\*(C'\fR method removes all user defined types from
the base class.  Any instances that are alread created will retain
their existing type configuration.
.Sh "mkpath"
.IX Subsection "mkpath"
This is a convenience function for people writing callbacks and user
defined type validation.  It takes either an array or array reference
and returns a string that represents the path to a specific item in
the configuration.  This might be useful if you're interested in
having your error messages be consistent with the rest of
\&\f(CW\*(C`Config::Validate\*(C'\fR.  This is available for export, but not exported
by default.  Note: this is a function, not a method.
.SH "AUTHOR"
.IX Header "AUTHOR"
Clayton O'Neill
.PP
Eval for e\-mail address: \f(CW\*(C`join('@', join('.', qw(cv 20 coneill)), 'xoxy.net')\*(C'\fR
.SH "LICENSE AND COPYRIGHT"
.IX Header "LICENSE AND COPYRIGHT"
Copyright (C) 2007\-2008 by Clayton O'Neill
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself, either Perl version 5.8.5 or,
at your option, any later version of Perl 5 you may have available.
